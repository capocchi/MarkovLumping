# -*- coding: utf-8 -*-
"""Scenario 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OehlMWFQpl4ncVPHM_sSNGwHietV8FQk
"""

import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
import numpy as np

def build_tree(data, G, current_node, depth, max_depth, parent_probability=1.0, original_cash = 1000000):

    if depth >= max_depth:
        return


    actions = [
        ((1, 0, 0), 1/7, -data[depth][1]), ((0, 1, 0), 1/7, -data[depth][2]), ((0, 0, 1), 1/7,-data[depth][3]),
        ((-1, 0, 0), 1/7, data[depth][1]), ((0, -1, 0), 1/7, data[depth][2]), ((0, 0, -1), 1/7, data[depth][3]),
        ((0, 0, 0), 1/7, 0)
    ]


    for action, action_probability, action_cash in actions:
        if current_node[1] + action[0] < 0 or current_node[2] + action[1] < 0 or current_node[3] + action[2] < 0:
            action_cash = 0

        new_node = (
            depth + 1,
            max(0, current_node[1] + action[0]),
            max(0, current_node[2] + action[1]),
            max(0, current_node[3] + action[2]),
            current_node[4] + action_cash
        )

        new_probability = parent_probability * action_probability
        new_cash = current_node[4] + action_cash

        print(new_node, current_node[4], action_cash, new_cash)

        if new_node not in G.nodes:
            G.add_node(new_node, probability=new_probability)
        else:
            G.nodes[new_node]['probability'] += new_probability

        G.add_edge(current_node, new_node)
        build_tree(data, G, new_node, depth + 1, max_depth, parent_probability=new_probability, original_cash=new_cash)


data = pd.read_csv('DJIA-NASDAQ.csv').to_numpy()
stock = pd.read_csv('DJIA-NASDAQ.csv').values
price = stock[:,1:4]
price_array = np.array(price)

G = nx.Graph()

root_node = (0, 0, 0, 0, 1000000)
start_depth = 0
end_depth = 2
build_tree(data, G, root_node, start_depth, end_depth)

for node in G.nodes():
    if 'probability' not in G.nodes[node]:
        G.nodes[node]['probability'] = 1.0

file_path = f"Scenario1_First_{end_depth}_Days.txt"

with open(file_path, 'w') as file:
    for node in G.nodes:
        probability = G.nodes[node].get('probability','N/A')
        file.write(f'{str(node)} {probability}\n')


###############################################
# ExÃ©cuter un autre script Python (script1.py)
##############################################

import subprocess

def import_graph_from_graphml(filename):
    return nx.read_graphml(filename)

def find_key(dictionary, key_to_search):
    for key in dictionary:
        if key[:-1] == key_to_search:
            return key
    return None

def update_node_cash_value(G, node, new_value):
    # 1. node exist ?
    if node in G.nodes():
        # 2. creat new node
        new_node = node[:-1] + (new_value,)
        
        # 3. copy existing attr
        node_attributes = G.nodes[node]
        
        # 4. add new node withe the new attr
        G.add_node(new_node, **node_attributes)
        
        # 5. reconnect new node to its neighbors
        edges = list(G.edges(node))
        for edge in edges:
            if edge[0] == node:
                G.add_edge(new_node, edge[1])
            else:
                G.add_edge(edge[0], new_node)
        
        # 6. delete old node
        G.remove_node(node)

    else:
        print("Node doesn't exist")

def execute_lumping(G, end_depth):
    fn = None

    while not fn:
        ### execute scripts for lumping process
        subprocess.run(["python", "extract_matrix.py", "Scenario1_First_2_Days.txt", "1", f"{end_depth}"])
        result = subprocess.run(["python", "main_loop.py", "..\Matrix\Yuxin\Scenario1_First_2_Days_day1_to_day2.dat"], capture_output=True, text=True)

        ### list of fusionned states
        for l in result.stdout.split('\n'):
            if 'exported' in l:
                fn = l.split(' ')[0]

    G_lumped = import_graph_from_graphml(fn)

    # print(nx.to_dict_of_dicts(G_lumped).keys())

    # print("Yuxin Graph Dict")
    yuxin_graph_dict = nx.to_dict_of_dicts(G)
    # print(yuxin_graph_dict)

    state_to_delete_list = []
    state_to_change_dict = {}
    for s,d in nx.to_dict_of_dicts(G_lumped).items():
        s_list = s.split('\n')
        ### if s_list contains more one element, we must make a fusion
        if len(s_list) > 1:
            new_prob = d[s]['weight']
            new_cash = 0.0
            nb = 1
            ### 1st element is the state to keep, the others are the states to delete
            for s1 in map(lambda a: a.strip(),s_list[1:]):
                ### key to search in yuxin_graph_dict
                key_to_search = tuple([2]+list(map(int,s1.strip())))
                finded_key = find_key(yuxin_graph_dict, key_to_search)
                ### add the finded key to the list of states to delete
                state_to_delete_list.append(finded_key)
                ### update cash
                new_cash += finded_key[-1]
                nb += 1
            ### 1st element is the state to keep
            key_to_search = tuple([2]+list(map(int,s_list[0].strip())))
            finded_key = find_key(yuxin_graph_dict, key_to_search)
            ### store the state to change with the new values for prob and cash
            state_to_change_dict[finded_key] = {'new_prob':new_prob, 'new_cash':new_cash/nb}

    print(f"Nodes to delete: {state_to_delete_list}")
    print(f"Nodes to change: {state_to_change_dict}")

    ### loop to update G
    for node in G.copy().nodes():
        if node in state_to_delete_list:
            G.remove_node(node)
        elif node in state_to_change_dict.keys():
            G.nodes[node]['probability'] = state_to_change_dict[node]['new_prob']
            update_node_cash_value(G,node,state_to_change_dict[node]['new_cash'])

    return G

execute_lumping(G, end_depth)

############################################
#
############################################

expected_assets = {}
expected_investment = {}
state_node = []

for node in G.nodes():
    state_node.append((node[0], node[1],node[2],node[3], node[4]))

state_node_array = np.array(state_node)

for i, node in enumerate(state_node_array):
    day = int(node[0])

    node_array = np.array(node)

    dot_product = np.dot(state_node_array[i][1:4], price_array[day])
    assets = dot_product + node[4]
    probability = G.nodes[(day, node[1], node[2], node[3], node[4])]['probability']

    #print(state_node_array[i][1:4], dot_product, probability, price_array[day])

    expect_invest = dot_product * probability
    expect_asset = assets * probability

    if day in expected_investment:
        expected_investment[day] += expect_invest
        expected_assets[day] += expect_asset
    else:
        expected_investment[day] = expect_invest
        expected_assets[day] = expect_asset

    print(expected_investment)

node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
cmap = matplotlib.colormaps['Oranges']

def custom_layout(G):
    pos = {}
    row_spacing = 20000
    col_spacing = 2000

    rows = {}
    for node in G.nodes():
        if node[0] not in rows:
            rows[node[0]] = []
        rows[node[0]].append(node)


    for row, nodes in rows.items():
        y = -row * row_spacing
        for i, node in enumerate(nodes):
            x = i * col_spacing
            pos[node] = (x, y)

    return pos

# pos = custom_layout(G)

pos = nx.spring_layout(G)

fig, ax = plt.subplots(figsize=(35, 10))

nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=4000, font_size=12, font_weight='bold', edge_color='gray', linewidths=1, arrows=False)

node_labels = {}
for node in G.nodes():
    state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
    prob_label = f"Prob: {G.nodes[node]['probability']:.2f}"  # Probability label
    cash_label = f"Cash: {node[4]:.0f}"  # Cash label
    node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center', ax=ax)

sm = plt.cm.ScalarMappable(cmap=cmap)
sm.set_array(node_colors)
cbar = plt.colorbar(sm, ax=ax)
cbar.set_label('Probability', rotation=270, labelpad=20,fontsize=15)
cbar.ax.tick_params(labelsize=15)

text = "Expected Investment Value\n"
for day, exp_assets in expected_investment.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"

fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=10, family='monospace')

fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=10, family='monospace')
#fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
#fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
#fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


plt.title("Stock Trading Tree", fontsize=20)
plt.axis('off')
plt.show()

node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
cmap = matplotlib.colormaps['Oranges']

# pos = custom_layout(G)

fig, ax = plt.subplots(figsize=(35, 10))

nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=4000, font_size=12, font_weight='bold', edge_color='gray', linewidths=1, arrows=False, ax=ax)

node_labels = {}
for node in G.nodes():
    state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
    prob_label = f"Prob: {G.nodes[node]['probability']:.2f}"  # Probability label
    cash_label = f"Cash: {node[4]:.0f}"  # Cash label
    node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center')

sm = plt.cm.ScalarMappable(cmap=cmap)
sm.set_array(node_colors)
cbar = plt.colorbar(sm, ax=ax)
cbar.set_label('Probability', rotation=270, labelpad=20,fontsize=15)
cbar.ax.tick_params(labelsize=15)

text = "Expected Assets\n"
for day, exp_assets in expected_assets.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"

fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=20, family='monospace')

fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=20, family='monospace')
#fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
#fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
#fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


plt.title("Stock Trading Tree", fontsize=20)
plt.axis('off')
plt.show()