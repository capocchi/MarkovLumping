# -*- coding: utf-8 -*-
"""Scenario 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OehlMWFQpl4ncVPHM_sSNGwHietV8FQk
"""

import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
import numpy as np
import time

REDUCE_WITH_KL = True
YUXIN_PRINT = False
LAST_DAY = 7
PLOT = False

end_depth = 2 if REDUCE_WITH_KL else LAST_DAY

def build_tree(data, G, current_node, depth, max_depth, parent_probability=1.0, original_cash = 1000000):

    if depth >= max_depth:
        return


    actions = [
        ((1, 0, 0), 1/7, -data[depth][1]), ((0, 1, 0), 1/7, -data[depth][2]), ((0, 0, 1), 1/7,-data[depth][3]),
        ((-1, 0, 0), 1/7, data[depth][1]), ((0, -1, 0), 1/7, data[depth][2]), ((0, 0, -1), 1/7, data[depth][3]),
        ((0, 0, 0), 1/7, 0)
    ]


    for action, action_probability, action_cash in actions:
        if current_node[1] + action[0] < 0 or current_node[2] + action[1] < 0 or current_node[3] + action[2] < 0:
            action_cash = 0

        new_node = (
            depth + 1,
            max(0, current_node[1] + action[0]),
            max(0, current_node[2] + action[1]),
            max(0, current_node[3] + action[2]),
            current_node[4] + action_cash
        )

        new_probability = parent_probability * action_probability
        new_cash = current_node[4] + action_cash

        if YUXIN_PRINT:
            print(new_node, current_node[4], action_cash, new_cash)

        if new_node not in G.nodes:
            G.add_node(new_node, probability=new_probability)
        else:
            G.nodes[new_node]['probability'] += new_probability

        G.add_edge(current_node, new_node)
        build_tree(data, G, new_node, depth + 1, max_depth, parent_probability=new_probability, original_cash=new_cash)

    return G

#
start_time = time.time()

data = pd.read_csv('DJIA-NASDAQ.csv').to_numpy()
stock = pd.read_csv('DJIA-NASDAQ.csv').values
price = stock[:,1:4]
price_array = np.array(price)

G = nx.Graph()

root_node = (0, 0, 0, 0, 1000000)
start_depth = 0

build_tree(data, G, root_node, start_depth, end_depth)

for node in G.nodes():
    if 'probability' not in G.nodes[node]:
        G.nodes[node]['probability'] = 1.0

file_path = f"Scenario1_First_{end_depth}_Days.dat"

with open(file_path, 'w') as file:
    for node in G.nodes:
        probability = G.nodes[node].get('probability','N/A')
        file.write(f'{str(node)} {probability}\n')

###############################################
# LUMPING PHASE
##############################################

import subprocess

def import_graph_from_graphml(filename):
    return nx.read_graphml(filename)

def find_key(dictionary, key_to_search):
    for key in dictionary:
        if key[:-1] == key_to_search:
            return key
    return None

def update_node_cash_value(G, node, new_value):
    # 1. node exist ?
    if node in G.nodes():
        # 2. creat new node
        new_node = node[:-1] + (new_value,)
        
        # 3. copy existing attr
        node_attributes = G.nodes[node]
        
        # 4. add new node withe the new attr
        G.add_node(new_node, **node_attributes)
        
        # 5. reconnect new node to its neighbors
        edges = list(G.edges(node))
        for edge in edges:
            if edge[0] == node:
                G.add_edge(new_node, edge[1])
            else:
                G.add_edge(edge[0], new_node)
        
        # 6. delete old node
        G.remove_node(node)

    else:
        print("Node doesn't exist")

def get_prob(G, node_str, yuxin_graph_dict):
    node_to_search = tuple([end_depth]+list(map(int, node_str.strip())))
    finded_node = find_key(yuxin_graph_dict, node_to_search)
    return G.nodes[finded_node]['probability'] if finded_node else 0.0

def execute_lumping(G, end_depth):
    
    if end_depth < 1:
        return 

    ### find the name of the graphml file that stored the results of the lumping process
    fn = None
    while not fn:
        ### execute scripts for lumping process
        cmd = ["python", "extract_matrix.py", f"Scenario1_First_{end_depth}_Days.dat", f"{end_depth-1}", f"{end_depth}"]
        subprocess.run(cmd, capture_output=True)
        cmd = ["python", "main_loop.py", f"..\Matrix\Yuxin\Scenario1_First_{end_depth}_Days_day{end_depth-1}_to_day{end_depth}.dat"]
        # print(cmd)
        result = subprocess.run(cmd, capture_output=True, text=True)

        ### list of fusionned states
        for l in result.stdout.split('\n'):
            if 'exported' in l:
                fn = l.split(' ')[0]

    G_lumped = import_graph_from_graphml(fn)

    # print(nx.to_dict_of_dicts(G_lumped).keys())

    # print("Yuxin Graph Dict")
    yuxin_graph_dict = nx.to_dict_of_dicts(G)
    # print(yuxin_graph_dict)

    state_to_delete_list = []
    state_to_change_dict = {}
    for s in nx.to_dict_of_dicts(G_lumped).keys():
        s_list = s.split('\n')
        ### if s_list contains more one element, we must make a fusion
        if len(s_list) > 1:
            # new_prob = d[s]['weight']
            new_prob = get_prob(G, s_list[0], yuxin_graph_dict)
            new_cash = 0.0
            nb = 1
            ### 1st element is the state to keep, the others are the states to delete
            for s1 in map(lambda a: a.strip(), s_list[1:]):
                ### key to search in yuxin_graph_dict
                key_to_search = tuple([end_depth]+list(map(int, s1.strip())))
                finded_key = find_key(yuxin_graph_dict, key_to_search)
                ### add the finded key to the list of states to delete
                state_to_delete_list.append(finded_key)
                ### update prob
                new_prob += get_prob(G,s1,yuxin_graph_dict)
                ### update cash
                new_cash += finded_key[-1] if finded_key else 0.0
                nb += 1
            ### 1st element is the state to keep
            key_to_search = tuple([end_depth]+list(map(int, s_list[0].strip())))
            finded_key = find_key(yuxin_graph_dict, key_to_search)
            ### store the state to change with the new values for prob and cash
            state_to_change_dict[finded_key] = {'new_prob': new_prob, 'new_cash': new_cash/nb}

    # print(f"Nodes to delete: {state_to_delete_list}")
    # print(f"Nodes to change: {state_to_change_dict}")

    ### loop to update G
    for node in G.copy().nodes():
        if node in state_to_delete_list:
            G.remove_node(node)
        elif node in state_to_change_dict.keys():
            G.nodes[node]['probability'] = state_to_change_dict[node]['new_prob']
            update_node_cash_value(G, node, state_to_change_dict[node]['new_cash'])

if REDUCE_WITH_KL:
    state_gain = []

    ### number of final nodes before the lumping process
    final_nodes_before = [node for node in G.nodes if G.degree(node) == 1]

    execute_lumping(G, end_depth)

    # trace the number of final nodes before and after the lumping
    final_nodes_after = [node for node in G.nodes if G.degree(node) == 1]
    state_gain.append(len(final_nodes_before) - len(final_nodes_after))

    print(f"Number of nodes before/after for day {end_depth}: {len(final_nodes_before)}/{len(final_nodes_after)}")

    for i in range(2, LAST_DAY, 1):
        start_depth = i
        end_depth = i+1
        for root_node in final_nodes_after:
            parent_probability = G.nodes[root_node]["probability"]
            original_cash = root_node[4]
            build_tree(data, G, root_node, start_depth, end_depth, parent_probability, original_cash)
        
            file_path = f"Scenario1_First_{end_depth}_Days.dat"
            with open(file_path, 'w') as file:
                for node in G.nodes:
                    probability = G.nodes[node].get('probability', 'N/A')
                    file.write(f'{str(node)} {probability}\n')

        final_nodes_before = [node for node in G.nodes if G.degree(node) == 1]
        
        execute_lumping(G, end_depth)
        
        final_nodes_after = [node for node in G.nodes if G.degree(node) == 1]
        
        print(f"Number of nodes before/after for day {end_depth}: {len(final_nodes_before)}/{len(final_nodes_after)}")

        state_gain.append(len(final_nodes_before) - len(final_nodes_after))

    print("Number of state removed during the process", state_gain)

############################################
# TRACE
############################################

expected_assets = {}
expected_investment = {}
state_node = []

for node in G.nodes():
    state_node.append((node[0], node[1],node[2],node[3], node[4]))

state_node_array = np.array(state_node)

for i, node in enumerate(state_node_array):
    day = int(node[0])

    node_array = np.array(node)

    dot_product = np.dot(state_node_array[i][1:4], price_array[day])
    assets = dot_product + node[4]
    probability = G.nodes[(day, node[1], node[2], node[3], node[4])]['probability']

    #print(state_node_array[i][1:4], dot_product, probability, price_array[day])

    expect_invest = dot_product * probability
    expect_asset = assets * probability

    if day in expected_investment:
        expected_investment[day] += expect_invest
        expected_assets[day] += expect_asset
    else:
        expected_investment[day] = expect_invest
        expected_assets[day] = expect_asset

    if YUXIN_PRINT:
        print(expected_investment)

#
end_time = time.time()

#
execution_time = end_time - start_time
print(f"Execution time : {execution_time} secondes")

text = "Expected Investment Value\n"
for day, exp_assets in expected_investment.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"
print(text)

text = "Expected Assets\n"
for day, exp_assets in expected_assets.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"
print(text)

############################################
# PLOT
############################################

if PLOT:

    node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
    cmap = matplotlib.colormaps['Oranges']

    def custom_layout(G):
        pos = {}
        row_spacing = 20000
        col_spacing = 2000

        rows = {}
        for node in G.nodes():
            if node[0] not in rows:
                rows[node[0]] = []
            rows[node[0]].append(node)


        for row, nodes in rows.items():
            y = -row * row_spacing
            for i, node in enumerate(nodes):
                x = i * col_spacing
                pos[node] = (x, y)

        return pos

    pos = custom_layout(G)

    # pos = nx.spring_layout(G)

    fig, ax = plt.subplots(figsize=(35, 10))

    nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=3000, font_size=10, font_weight='bold', edge_color='gray', linewidths=1, arrows=False)

    node_labels = {}
    for node in G.nodes():
        state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
        prob_label = f"{G.nodes[node]['probability']:.2f}"  # Probability label
        cash_label = f"{node[4]:.0f}"  # Cash label
        node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center', ax=ax)

    sm = plt.cm.ScalarMappable(cmap=cmap)
    sm.set_array(node_colors)
    cbar = plt.colorbar(sm, ax=ax)
    cbar.set_label('Probability', rotation=270, labelpad=20,fontsize=15)
    cbar.ax.tick_params(labelsize=15)

    text = "Expected Investment Value\n"
    for day, exp_assets in expected_investment.items():
        if day != 0:
            text += f"Day {day}: {exp_assets:.2f}\n"

    fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=10, family='monospace')

    fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=10, family='monospace')
    #fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


    plt.title("Stock Trading Tree", fontsize=20)
    plt.axis('off')
    plt.show()

    node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
    cmap = matplotlib.colormaps['Oranges']

    # pos = custom_layout(G)

    fig, ax = plt.subplots(figsize=(35, 10))

    nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=3000, font_size=10, font_weight='bold', edge_color='gray', linewidths=1, arrows=False, ax=ax)

    node_labels = {}
    for node in G.nodes():
        state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
        prob_label = f"{G.nodes[node]['probability']:.2f}"  # Probability label
        cash_label = f"{node[4]:.0f}"  # Cash label
        node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center')

    sm = plt.cm.ScalarMappable(cmap=cmap)
    sm.set_array(node_colors)
    cbar = plt.colorbar(sm, ax=ax)
    cbar.set_label('Probability', rotation=270, labelpad=20, fontsize=15)
    cbar.ax.tick_params(labelsize=15)

    text = "Expected Assets\n"
    for day, exp_assets in expected_assets.items():
        if day != 0:
            text += f"Day {day}: {exp_assets:.2f}\n"

    fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=20, family='monospace')

    fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=10, family='monospace')
    #fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


    plt.title("Stock Trading Tree", fontsize=20)
    plt.axis('off')
    plt.show()