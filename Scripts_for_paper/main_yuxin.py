# -*- coding: utf-8 -*-
"""Scenario 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OehlMWFQpl4ncVPHM_sSNGwHietV8FQk
"""

import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
import numpy as np
import time

REDUCE_WITH_KL = True
YUXIN_PRINT = False
LAST_DAY = 3
PLOT = True

end_depth = 2 if REDUCE_WITH_KL else LAST_DAY

def build_tree(data, G, current_node, depth, max_depth, parent_probability=1.0, original_cash = 1000000):

    if depth >= max_depth:
        return


    actions = [
        ((1, 0, 0), 1/7, -data[depth][1]), ((0, 1, 0), 1/7, -data[depth][2]), ((0, 0, 1), 1/7,-data[depth][3]),
        ((-1, 0, 0), 1/7, data[depth][1]), ((0, -1, 0), 1/7, data[depth][2]), ((0, 0, -1), 1/7, data[depth][3]),
        ((0, 0, 0), 1/7, 0)
    ]


    for action, action_probability, action_cash in actions:
        if current_node[1] + action[0] < 0 or current_node[2] + action[1] < 0 or current_node[3] + action[2] < 0:
            action_cash = 0

        new_node = (
            depth + 1,
            max(0, current_node[1] + action[0]),
            max(0, current_node[2] + action[1]),
            max(0, current_node[3] + action[2]),
            current_node[4] + action_cash
        )

        new_probability = parent_probability * action_probability
        new_cash = current_node[4] + action_cash

        if YUXIN_PRINT:
            print(new_node, current_node[4], action_cash, new_cash)

        if new_node not in G.nodes:
            G.add_node(new_node, probability=new_probability)
        else:
            G.nodes[new_node]['probability'] += new_probability

        G.add_edge(current_node, new_node)
        build_tree(data, G, new_node, depth + 1, max_depth, parent_probability=new_probability, original_cash=new_cash)

    return G

#
start_time = time.time()

data = pd.read_csv('DJIA-NASDAQ.csv').to_numpy()
stock = pd.read_csv('DJIA-NASDAQ.csv').values
price = stock[:,1:4]
price_array = np.array(price)

G = nx.Graph()

root_node = (0, 0, 0, 0, 1000000)
start_depth = 0

build_tree(data, G, root_node, start_depth, end_depth)

for node in G.nodes():
    if 'probability' not in G.nodes[node]:
        G.nodes[node]['probability'] = 1.0

file_path = f"Scenario1_First_{end_depth}_Days.dat"

with open(file_path, 'w') as file:
    for node in G.nodes:
        probability = G.nodes[node].get('probability','N/A')
        file.write(f'{str(node)} {probability}\n')

###############################################
# LUMPING PHASE
##############################################

import subprocess

def import_graph_from_graphml(filename):
    return nx.read_graphml(filename)

def find_key(dictionary, key_to_search):
    for key in dictionary:
        if key[:-1] == key_to_search:
            return key
    return None

def update_node_cash_value(G, node, new_value):
    # 1. node exist ?
    if node in G.nodes():
        # 2. creat new node
        new_node = node[:-1] + (new_value,)
        
        # 3. copy existing attr
        node_attributes = G.nodes[node]
        
        # 4. add new node withe the new attr
        G.add_node(new_node, **node_attributes)
        
        # 5. reconnect new node to its neighbors
        edges = list(G.edges(node))
        for edge in edges:
            if edge[0] == node:
                G.add_edge(new_node, edge[1])
            else:
                G.add_edge(edge[0], new_node)
        
        # 6. delete old node
        G.remove_node(node)

    else:
        print("Node doesn't exist")

def have_same_parent(G, node1, node2):
    """Check if two nodes have the same parent (common neighbor) in the undirected graph."""
    # Get neighbors of each node
    neighbors_node1 = set(G.neighbors(node1))
    neighbors_node2 = set(G.neighbors(node2))
    
    # Check for common neighbors
    common_neighbors = neighbors_node1.intersection(neighbors_node2)
    return len(common_neighbors) > 0

def check_nodes_parents(G, node_set):
    """Return a dictionary where keys are parents and values are lists of nodes that have the same parent."""
    parent_map = {}  # Dictionary to hold parents and corresponding nodes

    # Convert the set to a list to iterate through pairs
    node_list = list(node_set)

    # Iterate through all pairs of nodes in the node list
    for i in range(len(node_list)):
        for j in range(i + 1, len(node_list)):
            node1 = node_list[i]
            node2 = node_list[j]
            # Check if they have the same parent
            if have_same_parent(G, node1, node2):
                # Get common parents (neighbors)
                parents_node1 = set(G.neighbors(node1))
                parents_node2 = set(G.neighbors(node2))
                common_parents = parents_node1.intersection(parents_node2)

                for parent in common_parents:
                    if parent not in parent_map:
                        parent_map[parent] = []
                    parent_map[parent].append(node1)
                    parent_map[parent].append(node2)

    # Ensure each node only appears once per parent
    for parent in parent_map:
        parent_map[parent] = list(set(parent_map[parent]))  # Remove duplicates
    
    return parent_map  # Return the dictionary

def get_prob(G, node_str, yuxin_graph_dict):
    node_to_search = tuple([end_depth]+list(map(int, node_str.strip())))
    finded_node = find_key(yuxin_graph_dict, node_to_search)
    return G.nodes[finded_node]['probability'] if finded_node else 0.0

def execute_lumping(G, end_depth):
    
    print(f"execute lumping for day {end_depth}...")

    if end_depth < 1:
        print("Done!")
        return 

    ### find the name of the graphml file that stored the results of the lumping process
    fn = None
    while not fn:
        ### execute scripts for lumping process
        cmd = ["python", "extract_matrix.py", f"Scenario1_First_{end_depth}_Days.dat", f"{end_depth-1}", f"{end_depth}"]
        subprocess.run(cmd, capture_output=True)
        cmd = ["python", "main_loop.py", f"..\Matrix\Yuxin\Scenario1_First_{end_depth}_Days_day{end_depth-1}_to_day{end_depth}.dat"]
        # print(cmd)
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # print(result.stdout)

        ### list of fusionned states
        fn = next((line.split(' ')[0] for line in result.stdout.splitlines() if 'exported' in line), None)

    G_lumped = import_graph_from_graphml(fn)

    # print(nx.to_dict_of_dicts(G_lumped).keys())

    # print("Yuxin Graph Dict")
    yuxin_graph_dict = nx.to_dict_of_dicts(G)
    # print(yuxin_graph_dict)

    for s in nx.to_dict_of_dicts(G_lumped).keys():
        s_list = s.split('\n')
        ### if s_list contains more one element, we must make a fusion
        if len(s_list) > 1:
            L = set()
            for s1 in map(str.strip, s_list):
                ### key to search in yuxin_graph_dict
                key_to_search = tuple([end_depth]+list(map(int, s1.strip())))
                finded_key = find_key(yuxin_graph_dict, key_to_search)
                L.add(finded_key)

            res = check_nodes_parents(G,L)
            
            for parent,nodes in res.items():
                ### TODO : node to conserve could be the min of volatility
                node_to_conserve = nodes[0]
                G.nodes[node_to_conserve]['probability'] += np.sum([G.nodes[n]['probability'] for n in nodes if n != node_to_conserve])
                update_node_cash_value(G, node_to_conserve, np.mean([n[-1] for n in nodes]))

                for n in nodes:
                    if n != node_to_conserve:
                        print(f"Delete {n} node as child of {parent}")
                        G.remove_node(n)

    print("Done!")

    # exit()

    # state_to_delete_set = set()
    # state_to_change_dict = {}

    # for s in nx.to_dict_of_dicts(G_lumped).keys():
    #     s_list = s.split('\n')
    #     ### if s_list contains more one element, we must make a fusion
    #     if len(s_list) > 1:

    #         # new_prob = d[s]['weight']
    #         new_prob = get_prob(G, s_list[0], yuxin_graph_dict)
    #         new_cash, nb = 0.0, 1
            
    #         ### 1st element is the state to keep, the others are the states to delete
    #         for s1 in map(str.strip, s_list[1:]):
    #             ### key to search in yuxin_graph_dict
    #             key_to_search = tuple([end_depth]+list(map(int, s1.strip())))
    #             finded_key = find_key(yuxin_graph_dict, key_to_search)
    #             ### add the finded key to the list of states to delete
    #             state_to_delete_set.add(key_to_search)
    #             ### update prob
    #             new_prob += get_prob(G,s1,yuxin_graph_dict)
    #             ### update cash
    #             new_cash += finded_key[-1] if finded_key else 0.0
    #             nb += 1
    #         ### 1st element is the state to keep
    #         key_to_search = tuple([end_depth]+list(map(int, s_list[0].strip())))
    #         finded_key = find_key(yuxin_graph_dict, key_to_search)
    #         ### store the state to change with the new values for prob and cash
    #         state_to_change_dict[finded_key] = {'new_prob': new_prob, 'new_cash': new_cash/nb}

    # # print(f"Nodes to delete: {state_to_delete_list}")
    # # print(f"Nodes to change: {state_to_change_dict}")

    # ### loop to update G
    # for node in G.copy().nodes():
    #     if node[:-1] in state_to_delete_set:
    #         G.remove_node(node)
    #     elif node in state_to_change_dict.keys():
    #         G.nodes[node]['probability'] = state_to_change_dict[node]['new_prob']
    #         update_node_cash_value(G, node, state_to_change_dict[node]['new_cash'])

if REDUCE_WITH_KL:
    state_gain = []

    ### number of final nodes before the lumping process
    final_nodes_before = [node for node in G.nodes if G.degree(node) == 1]

    execute_lumping(G, end_depth)

    # trace the number of final nodes before and after the lumping
    final_nodes_after = [node for node in G.nodes if G.degree(node) == 1]
    state_gain.append(len(final_nodes_before) - len(final_nodes_after))
    print(f"Number of nodes before/after for day {end_depth}: {len(final_nodes_before)}/{len(final_nodes_after)}")
    print("Number of state removed during the process", state_gain)
    
    for i in range(2, LAST_DAY, 1):
        start_depth = i
        end_depth = i+1
        for root_node in final_nodes_after:
            parent_probability = G.nodes[root_node]["probability"]
            original_cash = root_node[4]
            build_tree(data, G, root_node, start_depth, end_depth, parent_probability, original_cash)
        
        file_path = f"Scenario1_First_{end_depth}_Days.dat"
        with open(file_path, 'w') as file:
            for node in G.nodes:
                probability = G.nodes[node].get('probability', 'N/A')
                file.write(f'{str(node)} {probability}\n')

        final_nodes_before = [node for node in G.nodes if G.degree(node) == 1]
        
        execute_lumping(G, end_depth)
        
        final_nodes_after = [node for node in G.nodes if G.degree(node) == 1]
        state_gain.append(len(final_nodes_before) - len(final_nodes_after))
        print(f"Number of nodes before/after for day {end_depth}: {len(final_nodes_before)}/{len(final_nodes_after)}")
        print("Number of state removed during the process", state_gain)

############################################
# TRACE
############################################

expected_assets = {}
expected_investment = {}
state_node = []

for node in G.nodes():
    state_node.append((node[0], node[1],node[2],node[3], node[4]))

state_node_array = np.array(state_node)

for i, node in enumerate(state_node_array):
    day = int(node[0])

    node_array = np.array(node)

    dot_product = np.dot(state_node_array[i][1:4], price_array[day])
    assets = dot_product + node[4]
    probability = G.nodes[(day, node[1], node[2], node[3], node[4])]['probability']

    #print(state_node_array[i][1:4], dot_product, probability, price_array[day])

    expect_invest = dot_product * probability
    expect_asset = assets * probability

    if day in expected_investment:
        expected_investment[day] += expect_invest
        expected_assets[day] += expect_asset
    else:
        expected_investment[day] = expect_invest
        expected_assets[day] = expect_asset

    if YUXIN_PRINT:
        print(expected_investment)

#
end_time = time.time()

#
execution_time = end_time - start_time
print(f"\nExecution time : {execution_time} secondes")

text = "Expected Investment Value\n"
for day, exp_assets in expected_investment.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"
print(text)

text = "Expected Assets\n"
for day, exp_assets in expected_assets.items():
    if day != 0:
        text += f"Day {day}: {exp_assets:.2f}\n"
print(text)

############################################
# PLOT
############################################

if PLOT:

    node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
    cmap = matplotlib.colormaps['Oranges']

    def custom_layout(G):
        pos = {}
        row_spacing = 2000
        col_spacing = 2000

        rows = {}
        for node in G.nodes():
            if node[0] not in rows:
                rows[node[0]] = []
            rows[node[0]].append(node)


        for row, nodes in rows.items():
            y = -row * row_spacing
            for i, node in enumerate(nodes):
                x = i * col_spacing
                pos[node] = (x, y)

        return pos

    # pos = custom_layout(G)

    pos = nx.spring_layout(G)

    fig, ax = plt.subplots(figsize=(35, 10))

    nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=3000, font_size=10, font_weight='bold', edge_color='gray', linewidths=1, arrows=False)

    node_labels = {}
    for node in G.nodes():
        state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
        prob_label = f"{G.nodes[node]['probability']:.2f}"  # Probability label
        cash_label = f"{node[4]:.0f}"  # Cash label
        node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center', ax=ax)

    sm = plt.cm.ScalarMappable(cmap=cmap)
    sm.set_array(node_colors)
    cbar = plt.colorbar(sm, ax=ax)
    cbar.set_label('Probability', rotation=270, labelpad=20,fontsize=15)
    cbar.ax.tick_params(labelsize=15)

    text = "Expected Investment Value\n"
    for day, exp_assets in expected_investment.items():
        if day != 0:
            text += f"Day {day}: {exp_assets:.2f}\n"

    fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=10, family='monospace')

    fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=10, family='monospace')
    #fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


    plt.title("Stock Trading Tree", fontsize=20)
    plt.axis('off')
    plt.show()

    node_colors = [G.nodes[node]['probability'] for node in G.nodes()]
    cmap = matplotlib.colormaps['Oranges']

    # pos = custom_layout(G)

    fig, ax = plt.subplots(figsize=(35, 10))

    nx.draw(G, pos, with_labels=False, node_color=node_colors, cmap=cmap, node_size=3000, font_size=10, font_weight='bold', edge_color='gray', linewidths=1, arrows=False, ax=ax)

    node_labels = {}
    for node in G.nodes():
        state_label = f"({node[1]}, {node[2]}, {node[3]})"  # State label
        prob_label = f"{G.nodes[node]['probability']:.2f}"  # Probability label
        cash_label = f"{node[4]:.0f}"  # Cash label
        node_labels[node] = f"{state_label}\n{prob_label}\n{cash_label}"


    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_color='black', verticalalignment='center')

    sm = plt.cm.ScalarMappable(cmap=cmap)
    sm.set_array(node_colors)
    cbar = plt.colorbar(sm, ax=ax)
    cbar.set_label('Probability', rotation=270, labelpad=20, fontsize=15)
    cbar.ax.tick_params(labelsize=15)

    text = "Expected Assets\n"
    for day, exp_assets in expected_assets.items():
        if day != 0:
            text += f"Day {day}: {exp_assets:.2f}\n"

    fig.text(0.6, 0.7, text, ha='center', va='center', fontsize=20, family='monospace')

    fig.text(0.22, 0.82, 'Root Node', ha='center', va='center', fontsize=10, family='monospace')
    #fig.text(0.30, 0.62, 'Day 1', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.47, 0.4, 'Day 2', ha='center', va='center', fontsize=20, family='monospace')
    #fig.text(0.73, 0.18, 'Day 3', ha='center', va='center', fontsize=20, family='monospace')


    plt.title("Stock Trading Tree", fontsize=20)
    plt.axis('off')
    plt.show()